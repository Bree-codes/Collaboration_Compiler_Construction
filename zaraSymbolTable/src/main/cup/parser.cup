package red.stevo.code.Lexer;

import java_cup.runtime.*;

parser code {:
  private ZaraLexer scanner;

  public parser(ZaraLexer s) {
    this.scanner = s;
  }

  public java_cup.runtime.Symbol scan() throws java.lang.Exception {
     return scanner.yylex();
  }

:};

terminal IDENTIFIER, CONSTANT, FLOAT, STRING_LITERAL, TRUE, FALSE;
terminal OPERATOR_ADD, OPERATOR_SUB, OPERATOR_MUL, OPERATOR_DIV, ASSIGN, OPERATOR_GREATER, OPERATOR_LESS, OPERATOR_AND;
terminal OPERATOR_GREATER_EQUAL, OPERATOR_LESS_EQUAL, OPERATOR_NOT, OPERATOR_OR, OPERATOR_DOT, OPERATOR_EQUAL;
terminal PUNCTUATION_CURLED_LEFT, PUNCTUATION_CURLED_RIGHT, PUNCTUATION_COMMA, PUNCTUATION_COLON;
terminal PUNCTUATION_SQUARE_LEFT, PUNCTUATION_SQUARE_RIGHT, DATATYPE;
terminal SEMI_COLON, PUNCTUATION_LEFT, PUNCTUATION_RIGHT, KEYWORD, OPERATOR_NOT_EQUAL;
terminal CONST, GLOBAL, BREAK, IN, WHILE, IF, ELSE, ELSEIF, DO, FOR, RETURN, CONTINUE, CLASS;

non terminal StmtList, Stmt, Expr, Term, Factor, l_declaration, initialize;
non terminal valueAssign, multipleAssign, multiAssignValue;
non terminal condition, boolTerm, boolFactor, relationOp;
non terminal ClassDecl, ClassBody, ClassMember, FuncDecl, VarDecl, ParamList, Param, ArgList;

precedence left OPERATOR_ADD, OPERATOR_SUB, OPERATOR_OR, OPERATOR_AND;
precedence left OPERATOR_MUL, OPERATOR_DIV;
precedence right OPERATOR_NOT;

start with StmtList;

//program execution starts here.
//errors are detected and handled here.
StmtList ::= StmtList Stmt {:System.out.println("Parsed StmtList: StmtList Stmt");:}
           |  {: System.out.println("Parsed empty StmtList"); :}
           | error SEMI_COLON  {: System.err.println("Error"); :}
           | error PUNCTUATION_CURLED_RIGHT  {: System.err.println("Error"); :}
           ;

// Statement rules, including class, function, and variable declarations
Stmt ::= VarDecl {: System.out.println("Parsed Stmt ::= VarDecl"); :}
         | IF PUNCTUATION_LEFT condition PUNCTUATION_RIGHT PUNCTUATION_CURLED_LEFT StmtList PUNCTUATION_CURLED_RIGHT
         | WHILE PUNCTUATION_LEFT condition PUNCTUATION_RIGHT PUNCTUATION_CURLED_LEFT StmtList PUNCTUATION_CURLED_RIGHT
         | FuncDecl {: System.out.println("Parsed Stmt ::= FuncDecl"); :}
         | ClassDecl {: System.out.println("Parsed Stmt ::= ClassDecl"); :}
         ;

// Class Declaration
ClassDecl ::= CLASS IDENTIFIER PUNCTUATION_CURLED_LEFT ClassBody PUNCTUATION_CURLED_RIGHT
  {:

  :}
  ;

// Class Body
ClassBody ::= ClassBody ClassMember
            | {: System.out.println("Parsed empty ClassBody"); :}
            ;

// Class Member (variables or functions)
ClassMember ::= VarDecl {: System.out.println("Parsed ClassMember ::= Variable Declaration"); :}
              | FuncDecl {: System.out.println("Parsed ClassMember ::= FuncDecl"); :}
              ;

// Variable Declaration
VarDecl ::= DATATYPE IDENTIFIER initialize
  {:
    System.out.println("Parsed VarDecl ::= DATATYPE IDENTIFIER initialize");
  :}
  ;

// Right-hand side of variable declaration (assignment or empty initialization)
initialize ::= ASSIGN valueAssign SEMI_COLON  {: System.out.println("Parsed initialize ::= ASSIGN valueAssign SEMI_COLON"); :}
             | SEMI_COLON    {: System.out.println("Parsed initialize ::= SEMI_COLON"); :}
             ;

// Value assignment
valueAssign ::= IDENTIFIER multipleAssign  {:System.out.println("Parsed valueAssign ::= multipleAssign");:}
              | STRING_LITERAL  {:System.out.println("Parsed valueAssign ::= STRING_LITERAL");:}
              | Expr  {:System.out.println("Parsed valueAssign ::= Expr");:}
              | condition  {:System.out.println("Parsed valueAssign ::= condition");:}
              ;

// Multiple assignment
multipleAssign ::= ASSIGN IDENTIFIER multipleAssign {:System.out.println("Parsed multipleAssign ::= ASSIGN IDENTIFIER multipleAssign");:}
                 | ASSIGN multiAssignValue {:System.out.println("Parsed multipleAssign ::= ASSIGN IDENTIFIER ");:}
                 ;

// Function Declaration
FuncDecl ::= DATATYPE IDENTIFIER PUNCTUATION_LEFT ParamList PUNCTUATION_RIGHT PUNCTUATION_CURLED_LEFT StmtList PUNCTUATION_CURLED_RIGHT
  {:

  :};

// Parameter List in Function Declaration
ParamList ::= ParamList PUNCTUATION_COMMA Param
            | Param
            | {: System.out.println("Parsed empty ParamList"); :};

Param ::= DATATYPE IDENTIFIER {: System.out.println("Parsed Param ::= DATATYPE IDENTIFIER"); :}
        ;

// Function Call
Expr ::= IDENTIFIER PUNCTUATION_LEFT ArgList PUNCTUATION_RIGHT
       {: System.out.println("Parsed Function Call"); :}
       ;

// Argument List in Function Call
ArgList ::= ArgList PUNCTUATION_COMMA Expr
          | Expr
          | {: System.out.println("Parsed empty ArgList"); :}
          ;

// Expression rules
Expr ::= Expr OPERATOR_ADD Term {:System.out.println("Parsed Expr: Expr OPERATOR_ADD Term");:}
       | Expr OPERATOR_SUB Term {:System.out.println("Parsed Expr: Expr OPERATOR_SUB Term");:}
       | Term {:System.out.println("Parsed Expr: Term");:}
       ;

// Term rules
Term ::= Term OPERATOR_MUL Factor {:System.out.println("Parsed Term: Term OPERATOR_MUL Factor");:}
       | Term OPERATOR_DIV Factor {:System.out.println("Parsed Term: Term OPERATOR_DIV Factor");:}
       | Factor {:System.out.println("Parsed Term: Factor");:}
       ;

// Factor rules
Factor ::= CONSTANT {:System.out.println("Parsed Factor: CONSTANT");:}
         | IDENTIFIER {:System.out.println("Parsed Factor: IDENTIFIER");:}
         | FLOAT {:System.out.println("Parsed Factor: FLOAT");:}
         | PUNCTUATION_LEFT Expr PUNCTUATION_RIGHT {:System.out.println("Parsed Factor: ( Expr )");:}
         ;

// Conditional expressions
condition ::= boolTerm {:System.out.println("Parsed condition ::= boolTerm");:}
              | condition OPERATOR_OR boolTerm {:System.out.println("Parsed condition ::= condition OPERATOR_OR boolTerm");:}
              ;

// Relational operators
relationOp ::= OPERATOR_NOT_EQUAL {:System.out.println("Parsed relationOp ::= OPERATOR_NO"); :}
            ;
