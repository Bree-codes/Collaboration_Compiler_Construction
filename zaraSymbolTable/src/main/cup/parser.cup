package red.stevo.code.Lexer;

import java_cup.runtime.*;

parser code {:
  private ZaraLexer scanner;

  public parser(ZaraLexer s) {
    this.scanner = s;
  }

  public java_cup.runtime.Symbol scan() throws java.lang.Exception {
     return scanner.yylex();
  }

:};

terminal IDENTIFIER, CONSTANT, FLOAT, STRING_LITERAL, TRUE, FALSE;
terminal OPERATOR_ADD, OPERATOR_SUB, OPERATOR_MUL, OPERATOR_DIV, ASSIGN, OPERATOR_GREATER, OPERATOR_LESS, OPERATOR_AND;
terminal OPERATOR_GREATER_EQUAL, OPERATOR_LESS_EQUAL, OPERATOR_NOT, OPERATOR_OR, OPERATOR_DOT, OPERATOR_EQUAL;
terminal PUNCTUATION_CURLED_LEFT, PUNCTUATION_CURLED_RIGHT, PUNCTUATION_COMMA, PUNCTUATION_COLON;
terminal PUNCTUATION_SQUARE_LEFT, PUNCTUATION_SQUARE_RIGHT, DATATYPE;
terminal SEMI_COLON, PUNCTUATION_LEFT, PUNCTUATION_RIGHT, KEYWORD, OPERATOR_NOT_EQUAL;
terminal CONST, GLOBAL, BREAK, IN, WHILE, IF, ELSE, ELSEIF, DO, FOR, RETURN, CONTINUE, CLASS;


non terminal StmtList, Stmt, Expr, Term, Factor, keywords, l_desclaration, key_1, key_2, key_3, initialize;
non terminal valueAssign, multipleAssign, firstmultipleAssign, multiAssignValue;
non terminal condition, boolTerm, boolFactor, relationOp;


precedence left OPERATOR_ADD, OPERATOR_SUB, OPERATOR_OR, OPERATOR_AND;
precedence left OPERATOR_MUL, OPERATOR_DIV;
precedence right OPERATOR_NOT;

start with StmtList;

StmtList ::= StmtList Stmt {:System.out.println("Parsed StmtList: StmtList Stmt");:}
           |  {: System.out.println("Parsed empty StmtList"); :}
           | error SEMI_COLON  {: System.err.println("Error"); :}
           | error PUNCTUATION_CURLED_RIGHT  {: System.err.println("Error"); :}
           ;

Stmt ::= l_desclaration initialize {: System.out.println("Parsed Stmt ::= r_desclaration initialize"); :}
        ;

//left hand variable declaration.
l_desclaration ::= keywords IDENTIFIER {: System.out.println("Parsed l_desclaration ::= keywords IDENTIFIER"); :}
                    ;

keywords ::= key_1 key_2 key_3  {: System.out.println("Parsed keywords ::= key_1 key_2 key_3"); :}
            ;

key_1 ::= GLOBAL {: System.out.println("Parsed key_1 ::= GLOBAL | "); :}
            |    {: System.out.println("Parsed key_1 ::= epsilon "); :}
            ;


key_2 ::= CONST  {: System.out.println("Parsed key_2 ::= CONST |"); :}
            |    {: System.out.println("Parsed key_2 ::= epsilon "); :}
            ;


key_3 ::= DATATYPE   {: System.out.println("Parsed key_3 ::= DATATYPE"); :}
         |           {: System.out.println("Parsed key_3 ::= epsilon "); :}
         ;

//right hand size of a declaration.
initialize ::= ASSIGN valueAssign SEMI_COLON  {:System.out.println("Parsed initialize ::= ASSIGN valueAssign SEMI_COLON");:}
                | SEMI_COLON    {:System.out.println("Parsed initialize ::= SEMI_COLON");:}
                ;

valueAssign ::= IDENTIFIER multipleAssign  {:System.out.println("Parsed valueAssign ::= multipleAssign");:}
                | STRING_LITERAL  {:System.out.println("Parsed valueAssign ::=  STRING_LITERAL");:}
                | OPERATOR_LESS DATATYPE OPERATOR_GREATER PUNCTUATION_SQUARE_LEFT Expr PUNCTUATION_SQUARE_RIGHT {:
                System.out.println("Parsed valueAssign ::= OPERATOR_LESS DATATYPE OPERATOR_GREATER PUNCTUATION_SQUARE_LEFT Expr PUNCTUATION_SQUARE_RIGHT");
                :}
                | Expr  {:System.out.println("Parsed valueAssign ::= Expr");:}
                | condition  {:System.out.println("Parsed valueAssign ::= condition");:}
                ;

multipleAssign ::= ASSIGN IDENTIFIER multipleAssign {:System.out.println("Parsed multipleAssign ::= ASSIGN IDENTIFIER multipleAssign");:}
                   | ASSIGN multiAssignValue {:System.out.println("Parsed multipleAssign ::= ASSIGN IDENTIFIER ");:}
                   ;


multiAssignValue ::= IDENTIFIER  {:System.out.println("Parsed multiAssignValue ::= IDENTIFIER");:}
                    | CONSTANT  {:System.out.println("Parsed multiAssignValue ::= CONSTANT");:}
                    | FLOAT  {:System.out.println("Parsed multiAssignValue ::= FLOAT");:}
                    | STRING_LITERAL  {:System.out.println("Parsed multiAssignValue ::= STRING_LITERAL");:}
                    | condition  {:System.out.println("Parsed valueAssign ::= condition");:}
                    ;

Expr ::= Expr OPERATOR_ADD Term {:System.out.println("Parsed Expr: Expr OPERATOR_ADD Term");:}
       | Expr OPERATOR_SUB Term {:System.out.println("Parsed Expr: Expr OPERATOR_SUB Term");:}
       | Term {:System.out.println("Parsed Expr: Term");:}
       ;

Term ::= Term OPERATOR_MUL Factor {:System.out.println("Parsed Term: Term OPERATOR_MUL Factor");:}
       | Term OPERATOR_DIV Factor {:System.out.println("Parsed Term: Term OPERATOR_DIV Factor");:}
       | Factor {:System.out.println("Parsed Term: Factor");:}
       ;

Factor ::= CONSTANT {:System.out.println("Parsed Factor: CONSTANT");:}
         | IDENTIFIER {:System.out.println("Parsed Factor: IDENTIFIER");:}
         | FLOAT {:System.out.println("Parsed Factor: FLOAT");:}
         | PUNCTUATION_LEFT Expr PUNCTUATION_RIGHT {:System.out.println("Parsed Factor: PUNCTUATION_LEFT Expr PUNCTUATION_RIGHT");:}
         ;


// working with condtionals.
condition ::= boolTerm   {:System.out.println("Parsedcondition ::= boolTerm  ");:}
              | condition  OPERATOR_OR boolTerm {:System.out.println("Parsedcondition ::=  condition  OPERATOR_OR boolTerm");:}
              ;


boolTerm ::= boolFactor    {:System.out.println("Parsed boolTerm ::= boolFactor");:}
            | boolTerm OPERATOR_AND boolFactor {:System.out.println("Parsed boolTerm ::=  boolTerm OPERATOR_AND boolFactor ");:}
            ;

boolFactor ::=  TRUE  {:System.out.println("Parsed boolFactor ::=   TRUE");:}
               | FALSE  {:System.out.println("Parsed boolFactor ::=  FALSE");:}
               | OPERATOR_NOT   {:System.out.println("Parsed boolFactor ::=  OPERATOR_NOT");:}
               | PUNCTUATION_LEFT condition PUNCTUATION_RIGHT   {:System.out.println("Parsed boolFactor ::= PUNCTUATION_LEFT condition PUNCTUATION_RIGHT");:}
               | Expr relationOp Expr   {:System.out.println("Parsed boolFactor ::= Expr relationOp Expr ");:}
               ;


relationOp ::=   OPERATOR_NOT_EQUAL  {:System.out.println("Parsed relationOp ::=  OPERATOR_NOT_EQUAL");:}
               | OPERATOR_GREATER   {:System.out.println("Parsed relationOp ::=  OPERATOR_GREATER ");:}
               | OPERATOR_LESS  {:System.out.println("Parsed relationOp ::=  OPERATOR_LESS");:}
               | OPERATOR_GREATER_EQUAL {:System.out.println("Parsed relationOp ::=   OPERATOR_NOT_EQUAL");:}
               | OPERATOR_LESS_EQUAL    {:System.out.println("Parsed relationOp ::=   OPERATOR_NOT_EQUAL");:}
               | OPERATOR_EQUAL {:System.out.println("Parsed relationOp ::=   OPERATOR_NOT_EQUAL");:}
               ;














